// Copyright (C) Thomas Gilray, 2017
// See the notice in LICENSE.md

#ifndef HASHTABLE__H
#define HASHTABLE__H

#include "compat.h"
#include <new>


// Reallocating hashtable class
template<typename K, typename V>
class hashtable
{
    struct KV
    {
        u64 h1;
        K k;
        V v;

        KV() : h1(0) { }
    };

    struct table
    {
        u64 size;
	KV* data;

        table() : size(0) { }
    }

private:
    array<table> tables;
    u64 size;

public:
    // Constructs an empty table
    hashtable()
      : data(64), size(0)
    {
    }


    // Destructor
    ~hashtable()
    {
        for (u32 i = 0; i < data.size(); ++i)
	  operator delete (data[i]);
        data = 0;
        size = 0;
	max = 0;
    }
    
    // Reallocates space for the table
    void reallocate()
    {
	const u32 oldsize = data.size();
	for (u32 i = 0; i < oldsize; ++i)
	{
	    	
        }
	    
	    
    }

    // Fetches a pointer to a V for the hash code and K provided
    inline V* get(u64 hash, const K& key)
    {
        hash = hash | 1;
        u64 pos = hash % max - 1;
        while (true)
	{
	    pos = (pos + 1) % max;
	    while (data[pos].h != 0 && data[pos].h != hash)
	        pos = (pos + 1) % max;
        
	    if (data[pos].h == 0)
            {
	        return 0;
	    }
            else if (data[pos].k == key)
            {
	        return &data[pos].v; 
     	    }
	}
    }

    // Insert an element into the hashmap
    inline void insert(u64 hash, const K& key, const V& value)
    {
        hash = hash|1;

        // Reallocate if necessary
        if (size*2 >= max)
	  reallocate(max > 3 ? max*3 : 4);

	u64 pos = hash % max - 1;
        while (true)
	{
	    pos = (pos+1) % max;
	    while (data[pos].h != 0 && data[pos].h != hash)
	        pos = (pos + 1) % max;
            
	    if (data[pos].h == 0)
            {
	        data[pos].h = hash;
	        data[pos].k = key;
	        data[pos].v = value;
		return;
	    }
            else if (data[pos].k == key)
            {
	        data[pos].v = value;
	        return; 
     	    }
	}
    }

    // Returns the number of key-value pairs
    u64 count() const
    {
        return size;
    }
};


#endif // HASHTABLE__H


